--@name Music Player 4
--@author Naki
--@include nakilibs/musicplayer4/tracklist.txt
--@shared

if SERVER then
    hook.add("PlayerSay", "Hey", function(ply, txt)
        if txt:sub(1, 9)=="!play id " and ply==owner() then
            net.start("playSong")
            net.writeString(string.explode(" ", txt, nil)[3])
            net.send()
        
            return ""
        elseif txt:sub(1, 10)=="!play url " and ply==owner() then
            net.start("playSongUrl")
            net.writeString(string.explode(" ", txt, nil)[3])
            net.send()
        
            return ""
        elseif txt:sub(1, 8)=="!volume " then
            net.start("setVolume")
            net.writeString(txt:sub(9))
            net.send()

            return ""
        end
    end)
end
parent = chip()

holoStore = hologram.create(parent:localToWorld(Vector(0,0,0)), parent:localToWorldAngles(Angle(0,0,0)), "models/holograms/icosphere2.mdl", Vector(25))
holoStore:setParent(chip())
holoStore:setMaterial("models/wireframe")
holoStore:setColor(Color(255,255,255,255))

holoStore:setNoDraw(true)
local centerTransform = Matrix()
centerTransform:setTranslation(Vector(x, y, 0)/2)

if CLIENT then
require("nakilibs/musicplayer4/tracklist.txt")
tracksSORTED = {}
function sortByName(t)
    local nameIndexMap = {}  -- Map to link names to their original tables
    local names = {}  -- Table to store names for sorting

    -- Extract names and store references to original tables
    for _, entry in ipairs(t) do
        table.insert(names, entry[2])  -- Assuming entry[2] is the 'name'
        nameIndexMap[entry[2]] = entry
    end

    -- Sort names alphabetically
    table.sort(names)

    -- Insert tables in sorted order into 'sorted'
    for _, name in ipairs(names) do
        table.insert(tracksSORTED, nameIndexMap[name])
    end
end

sortByName(tracklist2())
function tracklist()
    return tracksSORTED
end
local buffers = {"RT", "RT2"}
local buffernum = 1
render.createRenderTarget("RT")
render.createRenderTarget("RT2")
local centerTransform = Matrix()
centerTransform:setTranslation(Vector(512, 512, 0))

local songid = 1

local getTrackList = tracklist()

if songid > table.count(getTrackList) then
    songid = 1
elseif songid <=0 then
    songid = table.count(getTrackList)
end

local track = getTrackList[songid]
local url = track[1]
local name = track[2]
local _snd
net.receive("playSong", function(len)
    id = tonumber(net.readString())
    if not hasPermission("bass.loadURL", url) then
        return
    end
    local volume = volume or 1
    local getTrackList = tracklist()
    local track = getTrackList[id]
    local url = track[1]
    local name = track[2]
    playURL(url,name)
end)
net.receive("playSongUrl", function(len)
    if not hasPermission("bass.loadURL", url) then
        return
    end
    local volume = volume or 1
    local url = net.readString()
    local name = "Playing from URL"
    playURL(url,name)
end)
net.receive("setVolume", function(len)
    vol = tonumber(net.readString())
    if _snd && _snd:isValid() then
        _snd:setVolume(vol / 100)
    end
end)
function playURL(url2,name)
    print("Now playing "..name)
    wait=true
    if _snd != nil then 
        _snd:stop()
    end
    bass.loadURL(url2,"3d noblock",function(snd)
    _snd = snd
    if snd != nil then
        snd:play()
        snd:setPos(chip():getPos())
        snd:setFade(500,0)
        snd:setVolume(0)
        snd:setLooping(1)
        
        alpha = 0
        alpha2 = 0
        alpha3 = 0
        playing = false
    end
end)

end
local permissionSatisfied = hasPermission("bass.loadURL")
if permissionSatisfied then
    --playURL(url,name)
else
setupPermissionRequest({"bass.loadURL"},"https://cdn.discordapp.com/attachments/", true)
hook.add("permissionrequest", "", function()
    permissionSatisfied = hasPermission("bass.loadURL")
    if permissionSatisfied == true then
        --playURL(url,name)
    end
end)
end

local function inbox(boxdata)
    local boxpos = boxdata[1]
    local boxsize = boxdata[2]
    local boxpos1 = boxpos - boxsize / 2
    local boxpos2 = boxpos + boxsize / 2
    local localposx, localposy = render.cursorPos(player(), screenEnt)
    
    local xok = (localposx > boxpos1.x) and (localposx < boxpos2.x)
    local yok = (localposy > boxpos1.y) and (localposy < boxpos2.y)

    --if xok then print("xok") end
    --if yok then print("yok") end

    return xok and yok
end
local function openMenu()
    if menuOpen != false then
        menuOpen = false
        menuMoveCT = timer.curtime()
        scrolling = false
        scroll=0
        localposystore=0
    else
        menuOpen = true
        menuMoveCT = timer.curtime()
    end
end
    local menuTex = material.create("UnlitGeneric")
    local menuTex2 = material.createFromImage("icon16/folder.png", "alphatest")
    menuTex:setTexture("$basetexture", menuTex2:getName())
    
    local arrow = material.create("UnlitGeneric")
    local arrow2 = material.createFromImage("icon16/control_end.png", "alphatest")
    arrow:setTexture("$basetexture", arrow2:getName())
local function drawMenu()
    if menuOpen == nil then menuOpen = false end
    if menuMoveCT == nil then menuMoveCT = timer.curtime()-1 end
    local menuOpenToFloat = menuOpen and 1 or 0  -- Now it represents the target state correctly
    local progress = math.clamp((timer.curtime() - menuMoveCT) * 5, 0, 1)
    
    -- Lerp between closed (-512) and open (0) positions
    local menuMoveMath = menuOpenToFloat * progress + (1 - menuOpenToFloat) * (1 - progress)
    local menuPos = Vector(-512 + 512 * menuMoveMath, 0, 0)
    
    local dontHide = not (menuOpen == false and progress == 1)
    
    -- Get cursor position relative to the screen
    local localposx, localposy = render.cursorPos(player(), screenEnt)
    if scroll == nil then scroll = 0 end
    if localposystore == nil then localposystore = 0 end
    if isDragging == nil then isDragging = false end
    if getTrackList != nil then
        if localposy != nil and menuOpen == true and localposy > 60*(scrolling and 0 or 1) then
            if input.isMouseDown(MOUSE.MOUSE1) and isDragging == false then
                scroll=math.clamp(localposystore-localposy,0,35/2+(15+35)*table.count(getTrackList))
                scrolling = true
            else
                localposystore=localposy+scroll
                scrolling = false
            end
        end
        if dontHide then
            local menuHeight = 512 - 60  -- Height where the list disappears sooner
            local itemHeight = 35 + 15  -- Height per item including spacing
            local startIndex = math.max(1, math.floor(scroll / itemHeight))  -- First visible item
            local endIndex = math.min(#getTrackList, math.ceil((scroll + menuHeight) / itemHeight))  -- Last visible item
            
            local fadeStart = scroll + menuHeight + 512/2  -- Where fading begins
            local fadeEnd = fadeStart + (itemHeight * 4)  -- Fading fully disappears after 4 items
            
            for i = startIndex, endIndex do
                local song = getTrackList[i]
                
                local yPos = 35 / 2 + (itemHeight * i) - scroll
                local sinOffset = 5 * math.sin(math.rad((timer.curtime() * 0.5 + 0.25 * i) * 180))
            
                -- Adjusted fade calculation across multiple items
                local fadeFactor = math.min(1, math.max(0, (fadeEnd - (yPos + itemHeight * i)) / (fadeEnd - fadeStart)))
                local alpha = (1-fadeFactor) * 255  -- Scale from 0 to 255
                local alpha2 = fadeFactor * 255  -- Scale from 0 to 255
                
                -- Apply alpha to HSV color
                local colorRGB = Color((timer.curtime() * 10 + 180) % 360 - 180, 1, 1):hsvToRGB()
                colorRGB.a = alpha2
                render.setColor(colorRGB)
                render.drawRoundedBox(15, -25 + menuPos.x + sinOffset - alpha, yPos, 512 - 25, 48)
            
                -- Adjust black background fade for visibility
                local colorblack = Color(0, 0, 0)
                colorblack.a = math.clamp(alpha2 * 5, 0, 255)  -- Make background fade more dramatic
                render.setColor(colorblack)
                render.drawRoundedBox(10, -25 + 4 + menuPos.x + sinOffset - alpha, yPos + 4, 512 - 8 - 25, 40)
            
                -- Apply text with alpha fade
                render.setColor(colorRGB)
                local ExtraText = song[2]:sub(36, 36) ~= "" and "..." or ""
                render.drawText(20 + menuPos.x + sinOffset - alpha, yPos + 10, song[2]:sub(1, 33) .. ExtraText, TEXT_ALIGN.LEFT)
            end
            if secondPressCT != nil then
                if timer.curtime()-secondPressCT > 0.3 then
                    storeSong = nil
                    secondPress = 0
                    storeSongCurrent = nil
                end
            end
            if secondPressCT == nil then secondPressCT = timer.curtime() end
            if localposy != nil and progress == 1 then
                if progresslast == nil then progresslast = progress end
                
                -- Ensure correct precedence by grouping conditions
                if input.isMouseDown(MOUSE.MOUSE1) and wait != true and progresslast == progress and localposy > 60 then
                    if secondPress == nil then secondPress = 0 end
                    if storeSongCurrent == nil then storeSongCurrent = nil end
                    if down2 == nil then down2 = false end
                    if down2 != true then
                        down2 = true
                        if (timer.curtime()-secondPressCT) > 0.01 then
                            for i, song in ipairs(getTrackList) do
                                -- Calculate position values
                                local posX = -25 + menuPos.x + 5 * math.sin(math.rad((timer.curtime() * 0.5 + 0.25 * i) * 180))
                                local posY = 35 / 2 + (15 + 35) * i - scroll
                                local sizeX, sizeY = 512 - 25, 48
                            
                                -- Set boxdata with center position and size
                                local boxdata = {Vector(posX + sizeX / 2, posY + sizeY / 2, 0), Vector(sizeX, sizeY, 0)}
                            
                                -- Check if the cursor is inside the box
                                if inbox(boxdata) then
                                    if storeSong == nil then
                                        storeSong = i
                                    else
                                        storeSongCurrent = i
                                    end
                                    if storeSongCurrent == storeSong then
                                        secondPress = secondPress + 1
                                        secondPressCT = timer.curtime()
                                        storeSongCurrent = nil
                                        
                                    end
                                    if secondPress >= 1 then
                                        storeSong = nil
                                        secondPress = 0
                                        track = song
                                        url = track[1]
                                        name = track[2]
                                        volume = volume or 1
                                        playURL(url, name)
                                        openMenu()
                                    end
                                    
                                end
                            end
                        end
                        secondPressCT = timer.curtime()
                    end
                else
                    down2 = false
                end
            end
            -- Store progress for next frame
            progresslast = progress
        end
        
        if volume == nil then volume = 1 end
        -- Line 222: Volume Slider Code
        local sliderX, sliderY = 512/2-100, 25  -- Slider position
        local sliderWidth, sliderHeight = 200, 25
        local handleRadius = 25
        local isDragging = false
        
        -- If mouse is held, check if it's dragging the handle
        if scrolling == nil then scrolling = false end
        if input.isMouseDown(MOUSE.MOUSE1) and localposx != nil then
            print(scrolling)
            if isDragging or (localposx >= sliderX-5 and localposx <= sliderX + sliderWidth+5 
                and localposy >= sliderY and localposy <= sliderY + sliderHeight) and scrolling == false then
                isDragging = true
                volume = math.clamp((localposx - sliderX) / sliderWidth, 0, 1)
                if _snd != nil and _snd:isValid() then
                    _snd:setVolume(volume)
                end
            end
        else
            isDragging = false
        end
        
            
        render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())
        --render.drawRoundedBoxEx(15, menuPos.x, menuPos.y+512-5, 480, 5, false, false, false, true)
        
        render.drawRoundedBoxEx(15, 0, menuPos.y, 512, 70, false, true, false, true)
        
        render.setColor(Color(0,0,0))  -- Example gray color
        render.drawRoundedBoxEx(10, 0, menuPos.y+5, 512-5, 60, false, true, false, true)
        
        -- Draw slider background (using one of your predefined colors)
        render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())  -- Example gray color
        render.drawRoundedBox(15,sliderX-handleRadius/2*2, sliderY-handleRadius/2*0.75, sliderWidth+handleRadius*2, sliderHeight+handleRadius*0.7)
        
        render.setColor(Color(0,0,0))  -- Example gray color
        render.drawRoundedBox(10,sliderX-(handleRadius/2*2-5), sliderY-(handleRadius/2*0.75-5), sliderWidth+handleRadius*2-10, sliderHeight+handleRadius*0.7-10)
        
        -- Draw slider handle
        local handleX = sliderX + volume * sliderWidth
        render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())  -- White for contrast
        render.drawRoundedBox(5, handleX-handleRadius/2, sliderY-handleRadius/2 + sliderHeight / 2, handleRadius, handleRadius)
        
        render.drawRoundedBox(15,512-100,48/4,90,48)
        
        render.setColor(Color(0,0,0,255))
        render.drawRoundedBox(10,512-100+4,48/4+4,90-8,40)
        
        
        render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())
        render.drawRoundedBox(15,48/4,48/4,48,48)
        
        render.setColor(Color(0,0,0,255))
        render.drawRoundedBox(10,48/4+4,48/4+4,40,40)
        
        render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())
        render.drawRoundedBox(15,48/4+48+10,48/4,48,48)
        
        render.setColor(Color(0,0,0,255))
        render.drawRoundedBox(10,48/4+48+10+4,48/4+4,40,40)
        
        render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())
        render.setMaterial(menuTex)
        render.drawTexturedRect(48/4+8,48/4+8,32,32,0)
        
        render.setMaterial(arrow)
        render.drawTexturedRect(48/4+8+48+10,48/4+8,32,32,0)
        
        -- Show volume percentage
        render.drawText(sliderX + sliderWidth + 105, sliderY - 5, string.format("%.0f%%", volume * 100), TEXT_ALIGN.CENTER)
        
    end
end
hook.add("think","",function()
    if _snd != nil and isValid(_snd) then
        _snd:setPos(player():getPos())
    end
end)
hook.add("render","render_gui_stuff",function()
    screenEnt = screenEnt or render.getScreenEntity()
    local snd = _snd
    if screenEnt then
        render.setColor(Color(255, 255, 255))
        render.setFont("DermaLarge")
        if not permissionSatisfied then
            render.drawText(256, 256 - 32, "IF you run out of ram, use this command", 1)
            render.drawText(256, 256, "*sf_timebuffer_cl 0.1*", 1)
            render.drawText(256, 256 - 128, "GRANT ME PERMS FOR MUSIC", 1)
            return
        else
            render.setColor(Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB())
            if wait then
                if time == nil or timer.curtime()-time > 1 then time = timer.curtime() end
                if timer.curtime()-time < 0.33 then
                    addText = "."
                elseif timer.curtime()-time < 0.66 then
                    addText = ".."
                elseif timer.curtime()-time < 0.99 then
                    addText = "..."
                else
                    addText="..."
                end
                render.drawText(256, 256 - 32, "Now loading track"..addText, 1)
            else
                render.drawText(256, 256 - 128, "Music Player by Naki", 1)
                render.drawText(256, 256 - 32, "Controls:", 1)
                render.drawText(256, 256 + 0, "Mouse1 - Interact with buttons", 1)
                render.drawText(256, 256 + 32, "Mouse1 (Hold & Move) - Scroll song list", 1)
                render.drawText(256, 256 + 64, "Mouse1 (Double Tap) - Select song", 1)
                render.drawText(256, 256 + 128, "Open song list from the top left corner!", 1)
            end
            
        end
    
        
        if snd != nil and isValid(snd) then
            if not snd:isPaused() then
                if wait != false then
                    wait = false
                end
                
                local n = 64
                local scrnw = 512
                local fft = snd:getFFT(n)
        
                local nextbuffer = (buffernum%#buffers)+1
                
                
                alpha = alpha + 0.1
                alpha = math.clamp(alpha,0,1)
                
                alpha2 = alpha2 + 0.01
                alpha2 = math.clamp(alpha2,0,1)
                
                if alpha2 >= 1 then
                    alpha3 = alpha3 + 0.02
                    alpha3 = math.clamp(alpha3,0,1)
                end
                if alpha2 >= 1 then
                    if playing == false then
                        playing = true
                        if volume == nil then volume = 1 end
                        snd:setVolume(volume)
                        snd:setTime(0)
                    end
                end
                
                render.setRenderTargetTexture(buffers[buffernum])
                render.selectRenderTarget(buffers[nextbuffer])
                render.clear(Color(0,0,0,255))
                render.setColor(Color((timer.curtime()*10+180)%360-180, 1, alpha3):hsvToRGB())
                render.pushMatrix(centerTransform)
                
                if fft != nil then
                    for i=1, n do
                        local current = fft[i+1]
                        local next = fft[i]
                        
                        local width = scrnw/n
                        local pos = -(scrnw)+(((scrnw*2)/n)*(i-0.5))
                        local x = width+pos
                        local y = 5
                        local lx = width+pos
                        local ly = (current*512)
                        
                        render.drawRect(x,y,width,ly)
                    end
                end
                local length = snd:getLength()
                local time = snd:getTime()
                if playing == true then
                    progresspercent = 1-((length-time)/length)
                else
                    progresspercent = 0
                end
                
                render.setColor(Color((timer.curtime()*10+180)%360-180, 1, alpha3):hsvToRGB())
                
                render.drawRoundedBox(8,-500,-4,500*progresspercent*2,5)
                
                render.setColor(Color((timer.curtime()*10+180)%360-180, 1, alpha):hsvToRGB())
                render.drawText(0, -55, name, 1)
                
                render.popMatrix()
                render.selectRenderTarget()
                
                render.setColor(Color(255, 255, 255, 255))
                render.setRenderTargetTexture(buffers[nextbuffer])
                render.drawTexturedRect(0, 0, 512, 512)
                holoStore:setPos(screenEnt:getPos()-screenEnt:getUp()*150)
                holoStore:setAngles(Angle(35*math.sin(timer.systime()*360/1000),timer.systime()*5,35*math.cos(timer.systime()*90/1000)))
                holoStore:setColor(Color((timer.curtime()*10+180)%360-180, 1, alpha):hsvToRGB())
                holoStore:draw()
                
                --render.selectRenderTarget()
                buffernum = nextbuffer
            end
        end
        
        if wait == nil then wait = false end
        if menumoving == nil then menumoving = false end
        local localposx, localposy = render.cursorPos(player(), screenEnt)
        if localposx != nil then
            --render.drawText(localposx,localposy,math.ceil(localposx).." "..math.ceil(localposy),1)
            if input.isMouseDown(MOUSE.MOUSE1) and menumoving != true then
                if down == nil then down = false end
                if down != true then
                    down = true
                    local boxdata = {Vector(48/1.35,48/1.35,0),Vector(48,48,0)}
                    --render.drawRect(boxdata[1].x-boxdata[2].x/2,boxdata[1].y-boxdata[2].y/2,boxdata[2].x,boxdata[2].y)
                    if inbox(boxdata) then
                        openMenu()
                    end
                    local boxdata = {Vector(48/1.35+10+48,48/1.35,0),Vector(48,48,0)}
                    --render.drawRect(boxdata[1].x-boxdata[2].x/2,boxdata[1].y-boxdata[2].y/2,boxdata[2].x,boxdata[2].y)
                    if inbox(boxdata) then
                        if _snd != nil and _snd:isValid() then
                            if not _snd:isPaused() then
                                _snd:pause()
                            else
                                _snd:play()
                            end
                        end
                    end
                    
                end
            else
                down = false
            end
        end
        drawMenu()
        local colorRGB = Color((timer.curtime()*10+180)%360-180, 1, 1):hsvToRGB()
        if localposx != nil then
            if hideCursorLast == nil then hideCursorLast=Vector(localposx,localposy,0) end
            if hideCursorCT == nil then hideCursorCT=timer.curtime() end
            if hideCursorLast != Vector(localposx,localposy,0) then hideCursorCT = timer.curtime() end
            if timer.curtime() - hideCursorCT > 1 then hideCursor = true else hideCursor = false end
            if timer.curtime() - hideCursorCT <= 2 then
                local alphaMod = 255-255*math.clamp(-1+(timer.curtime() - hideCursorCT),0,1)
                colorRGB.a = alphaMod
                render.setColor(colorRGB)
                render.drawRect(localposx-4, localposy-4, 8, 8)
                render.setColor(Color(75,75,75,alphaMod))
                render.drawRectOutline(localposx-5, localposy-5, 10, 10, 2)
            end
            hideCursorLast=Vector(localposx,localposy,0)
        end
    end
end)
end
